#!python3
import sys
import re
from signal import signal, SIGPIPE, SIG_DFL

# make script pipeable and prevent BrokenPipe error when piping out. https://stackoverflow.com/questions/14207708/ioerror-errno-32-broken-pipe-python
signal(SIGPIPE, SIG_DFL)


def parse_line(line, is_separator_started, is_requests_section):
    is_equals_sign_re = "^={80}$"
    requests_re = "^-{4} Requests -{1,}$"

    #print only the requests information
    if is_separator_started and is_requests_section:
        sys.stdout.write(line)

    # Identify ========================== sections that start and end a section
    if re.search(is_equals_sign_re, line):
        is_separator_started = not is_separator_started
        if is_separator_started:
            sys.stdout.write(line)
        if not is_separator_started:
            sys.stdout.write("\n")
            is_requests_section = False;

    # Identify if we are in the correct section
    if re.search(requests_re, line):
        is_requests_section = not is_requests_section;
        if is_requests_section:
            sys.stdout.write(line)

    return is_separator_started, is_requests_section


def filter(log_file_name = "", fromStdin = False):
    is_separator_started = False
    is_requests_section = False

    if fromStdin:
        for line in sys.stdin:
            is_separator_started, is_requests_section = parse_line(line, is_separator_started, is_requests_section)
    else:
        with open(log_file_name, 'r') as fin:
            for line in fin:
                is_separator_started, is_requests_section = parse_line(line, is_separator_started, is_requests_section)


if __name__ == "__main__":

    if len(sys.argv) == 1:
        filter(fromStdin = True)
    elif len(sys.argv) < 2:
        sys.stderr.write("Too few args. Expected 1\n")
        sys.stdout.write("Usage: cmd <file_name>\n")
    else:
        # index 0 is the location of this script. first arg starts at index 1
        log_file_name = sys.argv[1];
        filter(log_file_name)
